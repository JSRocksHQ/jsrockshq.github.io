<?xml version="1.0"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>ES6 Rocks</title>
        <link>http://es6rocks.com</link>
        <description>A website dedicated to teach all about ES6</description>
        <managingEditor>ES6 Rocks</managingEditor>
        <webMaster>ES6 Rocks</webMaster>
        <pubDate>Wed, 05 Nov 2014 13:23:27 GMT</pubDate>
        <language>pt-br</language>
        <atom:link href="http://es6rocks.com/pt-br/rss.xml" rel="self" type="application/rss+xml" />
        
        <item>
            <title>使用6to5，让今天就来写ES6的模块化开发！</title>
            <link>http://es6rocks.com/pt-br/2014/11/6to5-es6</link>
            <description><![CDATA[<h1 id="-6to5-es6-">使用6to5，让今天就来写ES6的模块化开发！</h1>
]]></description>
            <pubDate>Wed, 05 Nov 2014 13:21:05 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/11/6to5-es6</guid>
        </item>
        
        <item>
            <title>Módulos ES6 hoje com o 6to5</title>
            <link>http://es6rocks.com/pt-br/2014/10/es6-modules-today-with-6to5</link>
            <description><![CDATA[<p>Eu postei a imagem abaixo no <a href="https://twitter.com/jaydson/status/526882798263881730">Twitter</a>, mostrando o quanto feliz eu etava.<br>É muito legal o que os <a href="http://en.wikipedia.org/wiki/Source-to-source_compiler">transpilers</a> podem fazer. No mundo do JavaScript é como uma máquina do tempo, onde podemos avançar para um futuro próximo de coisas muito legais que a ES6 irá nos trazer.<br>Nesse tutorial nós vamos mostrar como começar a escrever <a href="http://jsmodules.io/">ES6 modules</a> hoje, usando o excelente <a href="https://github.com/sebmck/6to5">6to5</a>;  </p>
<p><img src="/img/modules-today-6to5.png" alt="modules today with 6to5"></p>
<h1 id="primeiro-passo">Primeiro passo</h1>
<p>Se você não esta familiarizado com módulos ES6, por favor dê uma olhada no <a href="http://jsmodules.io/">JSModules.io</a> para ter uma breve introdução.<br>Eu também recomendo a leitura do artigo <a href="http://es6rocks.com/pt-br/2014/07/a-new-syntax-for-modules-in-es6/">Uma nova sintaxe para módulos na ES6</a> do <a href="http://twitter.com/jcemer">@jcemer</a>, aqui mesmo no <a href="http://es6rocks.com">ES6Rocks</a>, que cobre um monte de coisas mais legais sobre módulos no JavaScript.<br>Para esse tutorial nós vamos utilizar o 6to5 como transpiler.<br>Basicamente, o 6to5 converte código ES6 em vanilla ES5, fazendo com que você possa usar features de ES6 hoje mesmo.<br>O <em>6to5</em>  possui algumas vantagens sobre outros transpilers, aqui estão algumas das principais features:<br><strong>Readable</strong>: se possível, a formatação é mantida para que o seu código gerado seja o mais semelhante possível.<br><strong>Extensible</strong>: uma grande variedade de plugins e suporte a Browsers.<br><strong>Lossless</strong>: source map para que você possa depurar o código compilado com facilidade.<br><strong>Compact</strong>: mapeia diretamente para equivalente código ES5, sem qualquer necessidade de um runtime.  </p>
<h1 id="escrevendo-m-dulos">Escrevendo módulos</h1>
<p>Vamos começar a escrever módulos!<br>Nossa aplicação não vai fazer nada além de logs, mas a ideia principal aqui é fazer você entender como os módulos funcionam e como implementar módulos ES6 agora em suas aplicações.<br>Nossa app possui essa estrutura básica:  </p>
<pre><code>├── Gruntfile.js
├── package.json
└── src
    ├── app.js
    ├── modules
    │   ├── bar.js
    │   ├── baz.js
    │   └── foo.js
    └── sample
        └── index.html
</code></pre><p><code>app.js</code> é o arquivo principal, e dentro do diretório <code>modules</code> nós vamos armazenar os nossos módulos.<br>Dê uma olhada no app.js:  </p>
<pre><code class="lang-javascript">import foo from &quot;./modules/foo&quot;;
import bar from &quot;./modules/bar&quot;;

console.log(&#39;From module foo &gt;&gt;&gt; &#39;, foo);
console.log(&#39;From module bar &gt;&gt;&gt; &#39;, bar);
</code></pre>
<p>É bem simples. O código acima faz exatamente o que parece.<br>Nós estamos importando o módulo <code>foo</code> e o módulo <code>bar</code>, e então estamos logando o conteúdo de cada um.<br>Para ser mais claro, vamos olhar cada módulo:  </p>
<pre><code class="lang-javascript">// foo
let foo = &#39;foo&#39;;

export default foo;
</code></pre>
<pre><code class="lang-javascript">// bar
let bar = &#39;bar&#39;;

export default bar;
</code></pre>
<p>Em ambos os módulos, nós estamos apenas exportando as strings &#39;foo&#39; e &#39;bar&#39;.<br>Quando importamos o módulo, nossa variável passa a ter o valor que exportamos.<br>Então <code>foo</code> em <code>import foo from &quot;foo&quot;</code> possui o valor <code>&quot;foo&quot;</code> que exportamos em <code>export default foo</code>.<br>Você também pode exportar objetos, classes, funções, etc.<br>Agora, você pode começar a hackear este simples exemplo e escrever seus próprios módulos.  </p>
<h1 id="build">Build</h1>
<p>Como você deve saber, <a href="http://kangax.github.io/compat-table/es6/">módulos ES6 ainda não são suportados</a> por nenhum browser e nem no node.<br>A única maneira de escrever módulos ES6 hoje é usando um transpiler.<br>Como mencionei antes, estamos usando o 6to5, que faz exatamente o que queremos.<br>O task runner escolhido foi o <a href="http://gruntjs.com/">Grunt</a>, e vamos utilizar o <a href="https://github.com/sindresorhus/grunt-6to5">grunt-6to5</a>, projeto do <a href="https://twitter.com/sindresorhus">@sindresorhus</a>.  </p>
<pre><code class="lang-shell">npm install grunt-cli -g
npm install grunt --save-dev
npm install grunt-6to5 --save-dev
</code></pre>
<p>O nosso Gruntfile vai parecer com algo assim:  </p>
<pre><code class="lang-javascript">grunt.initConfig({
    &#39;6to5&#39;: {
        options: {
            modules: &#39;common&#39;
        },

        build: {
            files: [{
                expand: true,
                cwd: &#39;src/&#39;,
                src: [&#39;**/*.js&#39;],
                dest: &#39;dist/&#39;,
            }],
        }
    }
});
</code></pre>
<p>Uma configuração bem simples e estamos quase lá.<br>A task 6to5 roda o 6to5 no diretório <code>src</code> e faz o transpile do código para o diretório <code>dist</code>.<br>Note a opção <code>modules: &#39;common&#39;</code>. Essa opção diz para o 6to5 fazer o transpile dos módulos para ES5, usando o estilo de módulos <a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a>.<br>O 6to5 também suporta <a href="http://requirejs.org/docs/whyamd.html">AMD</a>, o que é muito legal, porque podemos integrar os módulos ES6 no nosso ambiente atual, independente do nosso estilo de módulos legado/atual escolhido.  </p>
<p>Para testar no browser, eu fiz uma copy task que apenas copia o arquivo <code>sample/index.html</code> para o diretório <code>dist</code>.<br>O arquivo HTML:  </p>
<pre><code class="lang-markup">&lt;!doctype html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;
    &lt;meta charset=&quot;UTF-8&quot;&gt;
    &lt;title&gt;ES6 modules 6to5&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    &lt;script src=&quot;//[cdnjs URL]/require.min.js&quot;&gt;&lt;/script&gt;
    &lt;script&gt;
        require([&#39;app.js&#39;]);
    &lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;
</code></pre>
<p>Olhe para o código acima, nós colocamos o RequireJS como a nossa biblioteca AMD e depois basta fazer um require da nossa app.<br>Para esse teste funcionar, você irá precisar alterar a opção <code>modules: amd</code>.  </p>
<h1 id="running">Running</h1>
<p>Agora que estamos com tudo pronto, você pode apenas rodar o <code>grunt</code>.<br>Se você perdeu algo até aqui, você pode clonar esse repositório <a href="https://github.com/es6rocks/es6-modules-today-with-6to5">es6-modules-today-with-6to5</a> e rodar <code>npm install</code>.<br>Lembre-se, a task do Grunt vai gerar o diretório <code>dist</code> com o código transpilado.<br>Se você escolher usar CommonJS, você pode testar a app com o node:  </p>
<pre><code class="lang-shell">node dist/app.js
</code></pre>
<p><img src="/img/running-node.png" alt="Running with node"></p>
<p>Se você optou por usar AMD, apenas sirva o diretório <code>dist</code>, e acesse a página <code>index.html</code>.<br><img src="/img/amd-es6.png" alt="AMD ES6"></p>
<h1 id="conclus-o">Conclusão</h1>
<p>Com este simples tutorial você pode ver como é fácil configurar um ambiente ES6 para trabalhar com módulos.<br>O 6to5 é uma excelente ferramente que você pode uasr hoje para transpilar código ES6 para ES5.<br>Forke o repositório <a href="https://github.com/es6rocks/es6-modules-today-with-6to5">es6-modules-today-with-6to5</a> e submeta issues, perguntas ou pull-requests.<br>Comentário são bem-vindos :)</p>
]]></description>
            <pubDate>Tue, 28 Oct 2014 12:49:54 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/10/es6-modules-today-with-6to5</guid>
        </item>
        
        <item>
            <title>JavaScript ♥  Unicode</title>
            <link>http://es6rocks.com/pt-br/2014/10/javascript-unicode</link>
            <description><![CDATA[<p>O Mathias Bynens deu uma palestra incrível na última edição da <a href="http://2014.jsconf.eu">JSConfEU</a>.<br>Ele falou sobre Unicode no JavaScript, e se você precisa trabalhar pesado com strings, você DEVE assistir esta palestra.<br>Na verdade, mesmo se você não pega tão pesado com strings no JavaScript, esses truques apresentados pelo Mathias são bem úteis.  </p>
<iframe width="560" height="315" src="//www.youtube.com/embed/zi0w7J7MCrk" frameborder="0" allowfullscreen></iframe>]]></description>
            <pubDate>Mon, 13 Oct 2014 19:22:32 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/10/javascript-unicode</guid>
        </item>
        
        <item>
            <title>Arrow Functions and their scope</title>
            <link>http://es6rocks.com/pt-br/2014/10/arrow-functions-and-their-scope</link>
            <description><![CDATA[<h1 id="arrow-functions-e-seu-escopo">Arrow Functions e seu escopo</h1>
<p>Entre as tantas novas features presentes no ES6, Arrow Functions (ou Fat Arrow Functions), é uma que merece boa atenção!
É muito legal, ótima para trabalhar com escopos, serve como &quot;atalho&quot; para algumas tecnicas que utilizamos hoje, diminui o código...
Mas pode ser um pouco mais difícil de ler caso não esteja a par de como ela funciona.
Então, vamos mergulhar no assunto!</p>
<h2 id="come-ando">Começando</h2>
<p>Para estudar e tester por você mesmo, você pode simplesmente copiar alguns dos exemplos deste artigo, e colar no console de seu browser.
Até o momento, você pode usar o Firefox(22+) Developer Tools, que já oferece suporte a arrow functions.
No Google Chrome, você precisará habilita-lo:</p>
<ul>
<li>- Habilite: Vá até &quot;about:flags&quot;, e habilite a opção &quot;Experimental JavaScript&quot;</li>
<li>- Use sempre em uma função em strict mode, por tanto, para rodar no console do Google Chrome, use:</li>
</ul>
<pre><code class="lang-javascript">(function(){
    &quot;use strict&quot;;
    // use arrow functions aqui
}());
</code></pre>
<p>Com tempo, felizmente, mais browsers suportarão as features do ES6.
Agora que tudo está preparado, vamos começar!</p>
<h2 id="um-novo-token">Um novo Token</h2>
<p>Um novo Token foi adicionado ao ES6, e é chamado &quot;fat arrow&quot;, representado por:</p>
<pre><code class="lang-javascript">=&gt;
</code></pre>
<h2 id="a-nova-sintaxe">A nova sintaxe</h2>
<p>Com este novo token, entra uma nova sintaxe:</p>
<pre><code class="lang-javascript">param =&gt; expression
</code></pre>
<p>Sintaxe a qual podemos usar algumas variações, de acordo com o número de statements na expressão, e número de parâmetros passados para a função:</p>
<pre><code class="lang-javascript">// single param, single statement
param =&gt; expression;

// multiple params, single statement
(param [, param]) =&gt; expression;

// single param, multiple statements
param =&gt; {
    statements;
}

// multiple params, multiple statements
([param] [, param]) =&gt; {
    statements
}

// with no params, single statement
() =&gt; expression;

// with no params
() =&gt; {
    statements;
}

// one statement, returning an object
([param]) =&gt; ({ key: value });
</code></pre>
<h2 id="como-funciona">Como funciona</h2>
<p>Se fossemos &quot;traduzir&quot; arrow functions para algo que já usamos hoje em dia, seria algo assim:</p>
<pre><code class="lang-javascript">// esta função
var func = function (param) {
    return param.split(&quot; &quot;);
}

// se tornaria:
var func= param =&gt; param.split(&quot; &quot;);
</code></pre>
<p>Isto quer dizer que esta sintaxe realmente retorna uma nova função, com os parâmetros e statements.
Ou seja, podemos chamar esta função do mesmo modo que já estamos acostumados:</p>
<pre><code class="lang-javascript">func(&quot;Felipe Moura&quot;); // retorna [&quot;Felipe&quot;, &quot;Moura&quot;]
</code></pre>
<h2 id="immediately-invoked-function-expression-iife-">Immediately-invoked function expression (IIFE)</h2>
<p>Sim, você pode invocar funções imediatamente, já que elas são na verdade, expressões.</p>
<pre><code class="lang-javascript">( x =&gt; x * 2 )( 3 ); // 6
</code></pre>
<p>Uma função será criada. Esta função recebe o parâmetro <code>x</code>, e retorna <code>x * 2</code>, então, é imediatamente executada passando o valor <code>3</code> como parâmetro.</p>
<p>Caso tenha mais statements ou parâmetros:</p>
<pre><code class="lang-javascript">( (x, y) =&gt; {
    x= x * 2;
    return x + y;
})( 3, &quot;A&quot; ); // &quot;6A&quot;
</code></pre>
<h2 id="considera-es-relevantes">Considerações Relevantes</h2>
<p>Considerando:</p>
<pre><code class="lang-javascript">var func = x =&gt; {
    return x++;
};
</code></pre>
<p>Podemos apontar algumas considerações relevantes:</p>
<p><strong>- <code>arguments</code> funciona exatamente como esperado</strong></p>
<pre><code class="lang-javascript">console.log(arguments);
</code></pre>
<p><strong>- <code>typeof</code> e <code>instanceof</code> também</strong></p>
<pre><code class="lang-javascript">func instanceof Function; // true
typeof func; // function
func.constructor == Function; // true
</code></pre>
<p><strong>- Usando parênteses internos, como sugerido pelo jsLint, NÃO funciona</strong></p>
<pre><code class="lang-javascript">// funciona, como sugerido pelo JSLint
(function (x, y){
    x= x * 2;
    return x + y;
} (3, &quot;B&quot;) );

// não funciona
( (x, y) =&gt; {
    x= x * 2;
    return x + y;
} ( 3, &quot;A&quot; ) );

// mas funcionaria, se a última linha fosse
// })(3, &quot;A&quot;);
</code></pre>
<p><strong>- Apesar de ser uma função, não funciona como um Constructor</strong></p>
<pre><code class="lang-javascript">var instance= new func(); // TypeError: func is not a constructor
</code></pre>
<p><strong>- Não tem um prototype</strong></p>
<pre><code class="lang-javascript">func.prototype; // undefined
</code></pre>
<h2 id="escopo">Escopo</h2>
<p>O <code>this</code> no escopo de arrow functions funciona de uma forma diferente.
No modo como estamos acostumados, <code>this</code> pode referenciar-se a: <code>window</code> (se for acessado globalmente), <code>undefined</code> (se acessado globalmente, em strict mode), uma <em>instância</em> (se em um construtor), um <em>objeto</em> (se for um método ou função dentro de um objeto ou instância) ou em um <code>.bind</code>/<code>.apply</code>. Pode ser também um <code>DOMElement</code>, por exemplo, quando usado em um addEventListener. <!-- TODO buscar melhor termo para "acessado globalmente" -->
Algumas vezes, isto incomoda bastante, ou pode até mesmo nos pegar de surpresa e causar algum problema!
Além disso, <em>this</em> é referenciado como <em>&quot;scope-by-flow&quot;</em> (fluxo-escopo). O que quero dizer com isto?</p>
<p>Vejamos primero, como <code>this</code> se comporta em diferentes situações:</p>
<p>Em um EventListener:</p>
<pre><code class="lang-javascript">document.body.addEventListener(&#39;click&#39;, function(evt){
    console.log(this); // o próprio HTMLBodyElement
});
</code></pre>
<p>Em instâncias:</p>
<pre><code class="lang-javascript">function Person () {
    let fullName = null;
    this.getName = function () {
        return fullName;
    };
    this.setName = function (name) {
        fullName = name;
        return this;
    };
}

let jon = new Person();
jon.setName(&quot;Jon Doe&quot;);
console.log(jon.getName()); // &quot;Jon Doe&quot;
</code></pre>
<p>Nesta situação em particular, uma vez que <code>Person.setName</code> é &quot;chainable&quot; (retornando a própria instância), poderíamos também usar assim:</p>
<pre><code class="lang-javascript">jon.setName(&quot;Jon Doe&quot;)
   .getName(); // &quot;Jon Doe&quot;
</code></pre>
<p>Em um objeto:</p>
<pre><code class="lang-javascript">let obj = {
    foo: &quot;bar&quot;,
    getIt: function () {
        return this.foo;
    }
};

console.log( obj.getIt() ); // &quot;bar&quot;
</code></pre>
<p>Mas então, vem a situação que citei acima, do formato escopo/fluxo.
Se tanto o fluxo ou o escopo mudam, <code>this</code> muda com ele.</p>
<pre><code class="lang-javascript">function Student(data){

    this.name = data.name || &quot;Jon Doe&quot;;
    this.age = data.age&gt;=0 ? data.age : -1;

    this.getInfo = function () {
        return this.name + &quot;, &quot; + this.age;
    };

    this.sayHi = function () {
        window.setTimeout( function () {
            console.log( this );
        }, 100 );
    }

}

let mary = new Student({
    name: &quot;Mary Lou&quot;,
    age: 13
});

console.log( mary.getInfo() ); // &quot;Mary Lou, 13&quot;
mary.sayHi();
// window
</code></pre>
<p>Uma vez que <code>setTimeout</code> muda o fluxo da execução, a referência ao <code>this</code> se torna a referência &quot;global&quot; (neste caso, <code>window</code>), ou <code>undefined</code> se em &quot;strict mode&quot;.
Por causa disto, acabamos usando algumas técnicas como o uso de variáveis como &quot;self&quot;, &quot;that&quot;, ou alguma coisa assim, ou tendo que usar <code>.bind</code>.</p>
<p>Mas não se preocupe, arrow functions estão aqui para ajudar!
Com arrow functions, o escopo é mantido com ela, de onde ela foi chamada.</p>
<p>Vejamos o MESMO exemplo acima, mas usando arrow function, passada para a chamada do _setTimeout.</p>
<pre><code class="lang-javascript">function Student(data){

    this.name = data.name || &quot;Jon Doe&quot;;
    this.age = data.age&gt;=0 ? data.age : -1;

    this.getInfo = function () {
        return this.name + &quot;, &quot; + this.age;
    };

    this.sayHi = function () {
        window.setTimeout( ()=&gt;{ // a única diferença está aqui
            console.log( this );
        }, 100 );
    }

}

let mary = new Student({
    name: &quot;Mary Lou&quot;,
    age: 13
});

console.log( mary.getInfo() ); // &quot;Mary Lou, 13&quot;
mary.sayHi();
// Object { name: &quot;Mary Lou&quot;, age: 13, ... }
</code></pre>
<h2 id="abordagens-teis-e-interessantes">Abordagens úteis e interessantes</h2>
<p>Já que é muito fácil criar arrow functions, e seus escopos funcionam como o mensionado, podemos usá-las de várias formas.</p>
<p>Por exemplo, podemos usa-las diretamente na chamada de um forEach, em uma Array:</p>
<pre><code class="lang-javascript">var arr= [&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;];
arr.forEach(vowel =&gt; {
console.log(vowel);
});
</code></pre>
<p>Ou em um <code>Array#map</code>:</p>
<pre><code class="lang-javascript">var arr= [&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;];
arr.map(vogal =&gt; {
    return vogal.toUpperCase();
});
// [ &quot;A&quot;, &quot;E&quot;, &quot;I&quot;, &quot;O&quot;, &quot;U&quot; ]
</code></pre>
<p>Ou em uma função recursiva:</p>
<pre><code class="lang-javascript">var fatorial = (n) =&gt; {
    if(n==0) {
        return 1;
    }
    return (n * fatorial (n-1) );
}

fatorial(6); // 720
</code></pre>
<p>Também, digamos, ordenando uma Array de trás para frente:</p>
<pre><code class="lang-javascript">let arr= [&#39;a&#39;, &#39;e&#39;, &#39;i&#39;, &#39;o&#39;, &#39;u&#39;];
arr.sort( (a, b)=&gt; a &lt; b? 1: -1 );
</code></pre>
<p>Ou em listeners:</p>
<pre><code class="lang-javascript">document.body.addEventListener(&#39;click&#39;, event=&gt;console.log(event, this)); // EventObject, BodyElement
</code></pre>
<h2 id="links-teis">Links úteis</h2>
<p>Aqui, pegue alguns links úteis para dar uma olhada:</p>
<ul>
<li>- <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">Arrow Functions na documentação da MDN</a></li>
<li>- <a href="http://tc39wiki.calculist.org/es6/arrow-functions/">TC39 Wiki sobre Arrow Function</a></li>
<li>- <a href="https://github.com/esnext">ESNext</a></li>
<li>- <a href="https://github.com/addyosmani/es6-tools">ES6 Tools</a></li>
<li>- <a href="https://www.npmjs.org/package/grunt-es6-transpiler">Grunt ES6 Transpiler</a></li>
<li>- <a href="http://www.es6fiddle.net/">ES6 Fiddle</a></li>
<li>- <a href="http://kangax.github.io/compat-table/es6/">ES6 Compatibility Table</a></li>
</ul>
<h2 id="conclus-o">Conclusão</h2>
<p>Mesmo que Arrow Functions tornem seu código um pouco mais complicado de ler (mas que você acaba se acostumando rápido), é uma grande solução para referências ao <code>this</code> em escopos e fluxos diferentes, um modo rápido para colocar as coisas para funcionar, e em parceria com o keyword <code>let</code>, levará nosso JavaScript para um próximo nível!
Experimente você mesmo, crie alguns testes, rode em seus browsers e deixe alguma solução ou uso interessante que encontrou, nos comentários!
Espero que tenha apreciado este artigo tanto quanto apreciará utilizar arrow functions em um futuro muito próximo!</p>
]]></description>
            <pubDate>Wed, 01 Oct 2014 04:01:41 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/10/arrow-functions-and-their-scope</guid>
        </item>
        
        <item>
            <title>O que podemos esperar do novo JavaScript</title>
            <link>http://es6rocks.com/pt-br/2014/08/what-is-next-for-javascript</link>
            <description><![CDATA[<p>Se você está interessado em ES6, você deve seguir o <a href="https://twitter.com/rauschma">Dr. Axel Rauschmayer</a>.<br>Ele mantêm o incrível blog <a href="http://www.2ality.com/">2ality</a> e escreve uma série de coisas legais sobre ES6.<br>Nessa sua talk ele fala sobre várias novas features da ES6 e mostra o que podemos esperar do futuro.  </p>
<script async class="speakerdeck-embed" data-id="4126347010d6013231af66d414c0f9a8" data-ratio="1.33333333333333" src="//speakerdeck.com/assets/embed.js"></script>  

<p>[UPDATE October, 2014]<br>The video is already online! (Thanks <a href="https://github.com/cirocosta">Ciro Costa</a> for point this).  </p>
<iframe width="560" height="315" src="//www.youtube.com/embed/G21rdWfa_as" frameborder="0" allowfullscreen></iframe>]]></description>
            <pubDate>Fri, 29 Aug 2014 03:04:03 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/08/what-is-next-for-javascript</guid>
        </item>
        
        <item>
            <title>O que você precisa saber sobre block scope - let</title>
            <link>http://es6rocks.com/pt-br/2014/08/what-you-need-to-know-about-block-scope-let</link>
            <description><![CDATA[<p>Declaração de variáveis em qualquer linguagem de programação é algo básico.<br>Independente da linguagem, entender o funcionamento do escopo de variáveis é imprescindível para escrever qualquer programa.<br>Em Python, por exemplo, assim como na maioria das linguagens, existem 2 escopos: Local e Global.<br>Variáveis definidas na raíz do arquivo, sem identação são variáveis de escopo Global.<br>Variáveis que são declaradas dentro do corpo de uma função são consideradas de escopo local.<br>Até aqui, tudo é muito parecido. No JavaScript o comportamente é bem semelhante.<br>Vejamos um exemplo nas 2 linguagens:  </p>
<pre><code class="lang-python"># Python
x = 1 # global scope
y = 3

def sum(a, b):
    s = a + b # local scope
    return s
</code></pre>
<pre><code class="lang-javascript">// JavaScript
var x = 1;  // global scope
var y = 3;

function sum(a, b) {
    var s = a + b;  // local scope
    return s;
}
</code></pre>
<p>Na maioria das linguagens baseadas em C (JavaScript, PHP), as variáveis são criadas no local onde foram declaradas.<br>Entretanto, no JavaScript isso é diferente, e pode se tornar complicado.<br>Ao declarar uma variável no corpo de uma função, a mesma é movida para o topo ou para o escopo global. Esse comportamento é chamado de <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/var#var_hoisting"><em>hoisting</em></a>.<br>Diferentemente de Python e outras linguagens, no JavaScript, uma variável declarada em um for loop acaba vazando o seu valor.<br>Veja no exemplo abaixo:  </p>
<pre><code class="lang-javascript">// JavaScript
for (var i = 0; i &lt;= 2; i += 1) {
    console.log(i); // current i
}
console.log(i); // last i
</code></pre>
<p>Neste caso, mesmo fora do bloco do for loop, a variável i ainda existe e com o último valor recebido no laço.<br>Este é um problema bem comum onde um programa pode ser facilmente quebrado por falta de atenção.  </p>
<p>Outro fator importante no JavaScript é que a omissão de <em>var</em> para declarar uma variável faz com que a mesma seja alocada no escopo global, e isso pode causar inúmeros problemas.  </p>
<h2 id="declara-o-let">Declaração let</h2>
<p>O <em>let</em> chega na ES6 como um substituto do <em>var</em>. Sim, a ideia é que var seja descontinuado em um futuro distante, pois hoje seria impossível não suporta-lo sem quebrar 100% da internet.<br>O <em>let</em> funciona como o esperado, definindo a variável no local onde ela foi declarada.<br>Exemplo:  </p>
<pre><code class="lang-javascript">let foo = true;
if  (foo) {
    let bar = &#39;baz&#39;;
    console.log(bar); // outputs &#39;baz&#39;
}

try {
    console.log(bar);
} catch (e) {
    console.log(&quot;bar doesn&#39;t exist&quot;);
}
</code></pre>
<p>Como você já deve imaginar, com <em>let</em> é possível resolver o problema com a variável no for loop.<br>Veja:  </p>
<pre><code class="lang-javascript">// JavaScript
for (let i = 0; i &lt;= 2; i += 1) {
    console.log(i); // current i
}
try {
    console.log(i);
} catch (e) {
    console.log(&quot;i doesn&#39;t exist&quot;);
}
</code></pre>
<h2 id="suporte-atual">Suporte atual</h2>
<p>Você pode usar <em>let</em> hoje*<br>Olhe a excelente tabela ES6 feita pelo Kangax &gt; <a href="http://kangax.github.io/compat-table/es6/#">http://kangax.github.io/compat-table/es6/#</a>.<br><em>let</em> é atualmente suporttado pelos browsers modernos(até no IE11) em suas últimas versões e no <a href="https://github.com/google/traceur-compiler">Traceur</a>.<br>Você pode brincar com ES6 <em>let</em> no Firefox devtools:  </p>
<p><img src="/img/let.gif" alt="let on firefox nightly">  </p>
<ul>
<li><strong>NOTA</strong>: Como bem apontado pelo Michał Gołębiowski nos comentários (post em inglês <a href="http://es6rocks.com/2014/08/what-you-need-to-know-about-block-scope-let/#comment-1576757325">http://es6rocks.com/2014/08/what-you-need-to-know-about-block-scope-let/#comment-1576757325</a>), as implementações atuais dos browsers não estão totalmente de acordo com a especificação, então é possível encontrar alguns bugs.<br>Para aplicações do mundo real, você precisará utilizar um transpiler(pelo menos por enquanto, até o meio de 2015).  </li>
</ul>
<h2 id="conclus-o">Conclusão</h2>
<p>Apesar de simples, declarar variáveis no JavaScript pode causar dor de cabeça em iniciantes na linguagem.<br>Com o <em>let</em>, declarar variáveis fica muito mais intuítivo e coerente com uma linguagem baseada em C.<br>O uso do <em>var</em> deve ser descontinuado, e apenas o <em>let</em> deve existir no futuro.<br>Não existe o comportamento de <em>hoisting</em> para variáveis declaradas com <em>let</em>.  </p>
<h2 id="outras-refer-ncias">Outras referências</h2>
<p><a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-let-and-const-declarations">https://people.mozilla.org/~jorendorff/es6-draft.html#sec-let-and-const-declarations</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let</a><br><a href="http://odetocode.com/blogs/scott/archive/2014/07/31/the-features-of-es6-part-1-let.aspx">http://odetocode.com/blogs/scott/archive/2014/07/31/the-features-of-es6-part-1-let.aspx</a>  </p>
]]></description>
            <pubDate>Thu, 28 Aug 2014 01:58:23 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/08/what-you-need-to-know-about-block-scope-let</guid>
        </item>
        
        <item>
            <title>Uma nova sintaxe para módulos na ES6</title>
            <link>http://es6rocks.com/pt-br/2014/07/a-new-syntax-for-modules-in-es6</link>
            <description><![CDATA[<p>O grupo TC39 - ECMAScript já está finalizando a sexta versão da especificação do ECMAScript. A <a href="http://www.2ality.com/2014/06/es6-schedule.html">agenda do grupo</a> aponta o mês de junho do próximo ano como sendo a data de lançamento. A partir de agora, poucas mudanças significativas devem surgir. Já é tempo de se aprofundar no estudo.</p>
<p>Este artigo não pretende abordar a importância da escrita de código modularizado. Já escrevi sobre o assunto no artigo <a href="http://tableless.com.br/modularizacao-em-javascript">Modularização em JavaScript</a>. Sites como <a href="http://jsmodules.io">JavaScript Modules</a> entre outros já são uma ótima referência sobre como escrever módulos ES6. A intenção aqui é esclarecer e justificar a necessidade de uma nova sintaxe para escrita de módulos.</p>
]]></description>
            <pubDate>Fri, 11 Jul 2014 07:18:47 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/07/a-new-syntax-for-modules-in-es6</guid>
        </item>
        
        <item>
            <title>Entrevista sobre ES6 com o David Herman</title>
            <link>http://es6rocks.com/pt-br/2014/07/es6-interview-with-david-herman</link>
            <description><![CDATA[<p>Fizemos uma entrevista bem legal com o <a href="https://twitter.com/littlecalculist">David Herman</a> sobre ES6.<br>Para quem não conhece, o David é o principal pesquisador e fundador da Mozilla Research, onde ele trabalha para expandir as fundações da Open Web. Ele está envolvido com diversos projetos de plataformas Web, incluindo <a href="http://taskjs.org/">task.js</a>, <a href="http://sweetjs.org/">sweet.js</a>, <a href="http://asmjs.org/">asm.js</a>, <a href="http://www.rust-lang.org/">Rust</a>, <a href="https://github.com/mozilla/servo/">Servo</a> e Parallel JS.  </p>
]]></description>
            <pubDate>Fri, 04 Jul 2014 01:08:30 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/07/es6-interview-with-david-herman</guid>
        </item>
        
        <item>
            <title>Workflows para os módulos da ES6, Fluent 2014</title>
            <link>http://es6rocks.com/pt-br/2014/05/practical-workflows-es6-modules</link>
            <description><![CDATA[<p>O <a href="https://twitter.com/guybedford">Guy Bedford</a> deu um palestra incrível sobre workflows com módulos ES6 no último mês na Fluent Conf.
Ele também escreveu um artigo sonre isso. Se você está interessado neste assunto, você deve ler o artigo por completo.</p>
]]></description>
            <pubDate>Tue, 27 May 2014 07:18:47 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/05/practical-workflows-es6-modules</guid>
        </item>
        
        <item>
            <title>ECMAScript 6 - Um melhor JavaScript para a Ambient Computing Era</title>
            <link>http://es6rocks.com/pt-br/2014/05/ecmascript-6-a-better-javascript-for-the-ambient-computing-era</link>
            <description><![CDATA[<p>Allen Wirfs-Brock (<a href="https://twitter.com/awbjs">awbjs</a> no Twitter) é um membro do comitê TC39. Na verdade, ele é o &quot;Project Editor of the ECMAScript Language Specification&quot;, ou seja, editor chefe da ECMA.  </p>
]]></description>
            <pubDate>Tue, 27 May 2014 06:18:47 GMT</pubDate>
            <guid>http://es6rocks.com/pt-br/2014/05/ecmascript-6-a-better-javascript-for-the-ambient-computing-era</guid>
        </item>
        
    </channel>
</rss>
